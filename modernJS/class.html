<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>class</title>
</head>
<body>
    <script>
       //기본적인 생성자 함수
       const User = function(name, age) {
           this.name = name;
           this.age = age;
           /* 
           this.showName = function() {
               console.log(this.name);
           }; 
           */
       };

       User.prototype.showName = function() {
        console.log(this.name);
       }
       //class와 동일하게 만들어주려면 이렇게 쓸순 있음

       const mike = new User("mike", 30);

       //es6에서 추가된 class
       class User2 {
           constructor(name , age) {
               this.name = name;
               this.age = age;
           }
           showName() { //프로퍼니와 다르게 클래스의 메서드는 User2의 proto에 할당됨
               console.log(this.name);
           }
       }

       const tom = new User2('tom', 19);
       console.log(tom);

       //그럼 단순히 문법의 편의성을 위해 class가 만들어진걸까 그건 아님

       //1. 오류확인 : 25번 시트의 new생성자를 빼고 확인해보면 undifined가 된다 엄연히 사용자가 실수한 코드지만 오류를 반환하지 않는다
       //반면 class의 경우 new생성자를 써야한다는 오류를 반환한다

       //2. 순환의 차이 
       for(const p in mike) {
           console.log(p);
       }

       for(const p in tom) {
           console.log(p);
       }
       //forIn문은 prototype은 순환 하지 않기 때문에 콘솔에 찍히지 않음




    </script>
</body>
</html>